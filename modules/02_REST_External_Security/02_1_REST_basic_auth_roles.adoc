:noaudio:
:sourcedir: ../code/security-ws/src/test/java
:toc2:

= REST Security with Basic Authentication and Role Lab

In this lab you resolve the following use cases:

<<usecase1>>

<<usecase2>>

.Goals
* Configure your local environment to develop and resolve use cases
* Become more experimented about Basic Authentication Jetty Server
* Restrict the access to certain paths based on the role of the user
* Design RESTfull Service project and secure it
* Expose the RESTfull services using a Camel route
* Configure the Jetty Endpoint to authenticate the HTTP User request using the HashLoginService
* Send the HTTP Request using Apache Commons HttpClient

.Prerequisites
* Experience with Java, Spring & Apache Maven
* Expertise with RESTfull & HTTP Basic Authentication
* Complete Red Hat OPEN course: Camel Development with Red Hat JBoss Fuse

:numbered:
== Install Lab assets

|===
| Software | Version & URL | Notes |

| Java SE | http://www.oracle.com/technetwork/java/javase/downloads/index.html[1.8 or higher] | Required |
| Apache Maven | http://maven.apache.org[3.0.5 or higher] | Required |
| JBoss Developer Studio | http://www.jboss.org/products/devstudio/overview/[9.0.GA] | Required |
| Integration Stack | https://devstudio.jboss.com/9.0/stable/updates/[9.0] | Required |
|===

=== Install the lab project

Download the latest release of the project published on the following GitHub repository: {course_git_repo} and install it locally. As this project contains the skeleton of the code
that you will use to resolve the use cases, we suggest that you next import it in a new Workspace of JBoss Developer Studio.


== Use case exercise

The different use cases should be developed as a collection of Java JUnit Test class within the corresponding Maven module part of the skeleton project.

[[usecase1]]
=== Secure the Jetty Component using a Security Handler

The goal of this use case is to design a Junit Test case using the class +org.jboss.fuse.security.camel.basic.BasicAuthRESTCamelDSLJettyHashLoginTest.java+ which extend the class +BaseJettyTest+ class.

Within this project, you will setup an Apache Camel Route, use the REST DSL syntax to expose a RESTfull service according to this path +/say/hello/{id}+ where {id} represents the user for which you would like to say hello
. Next, you will configure the Jetty Component using the Jetty SecurityHandler class to authenticate the user HTTP request using Basic Authentication & Base64.

The +org.eclipse.jetty.security.SecurityHandler+ will be configured to request Basic Authentication and will use the +org.eclipse.jetty.security.HashLoginService+ class to authenticate
the user using a properties file called +src/test/resources/org/jboss/fuse/security/basic/myrealm.props+. This property file will contain a list of users defined as such :
user: password, role.

For this use case, you must create 2 java methods +UsernameWrongPasswordTest()+ and +UsernameTest()+ to test the credentials of a user having either a correct or wrong password.
Use the method HTTPClient to issue the HTTP request against the RESTFull Endpoint started by Apache Camel with the help of this method +callRestEndpoint()+

NOTE: The +BaseJettyTest+ class extends the +CamelTestSupport+ class


[[usecase2]]
=== Generate SOAP Header with WSSE : username, timestamp & password

This usecase extends the previous but instead of sending a wrong password, you will send the correct password assigned to your username within the WSSE Section of the SOAP Header. Please use the `passwordCallbackClass` as WSS4J parameter
to let the Interceptor to get the password from the `PwdCallback` implementing the `CallbackHandler` interface. Within the handle method, loop within the list of the users till you find the user and assign the password
to the `WSPasswordCallback` object using the `setPassword` property.

Use the same Actions as defined for the Usecase 1 in order to generate a header containing the user credential and the timestamp.

[[usecase3]]
=== Generate a SOAP Message & sign its content

The goal of this use case is to sign the body of the message and its timestamp. The algorithms to be used to digest the signed content is +http://www.w3.org/2001/04/xmlenc#sha256+ while the algorithm to be used to sign the content is +http://www.w3.org/2000/09/xmldsig#rsa-sha1+.
You will need to set the Signature and TimeStamp actions (username token does not need to be set).

Signing a message validates to the receiver that the message was not altered in transit and could only have come from a certain sender. The sender encrypts a digest (hash) of the message with its private key, and the recipient decrypts the hash with the sender's public key.  It checks that the digest values calculated by both the sender and recipient are the same. The student  must ensure that the Client's public key has been imported into the server's keystore using keytool.

Please use these parameters to configure the WSS4J class :

- Actions : Timestamp and Signature
- Parts to be signed : signatureParts
- Parts : body and timestamp
- Sign Algorithm : signatureAlgorithm
- Digest Sign Algorithm : signatureDigestAlgorithm

[WARNING]
====
* Take care to configure accordingly the Server and/or client classes and the In/Out interceptors
* Use the appropriate user to sign the message based on the key associated to its certificate
====

[[usecase4]]
=== Generate a SOAP Message & sign/encrypt the content

For this last use case, you will encrypt and sign the content of the message.

Encryption involves the sender encrypting the message with the recipient's public key to ensure that only the recipient can read the message (only the recipient has its own private key, necessary for decrypting the message.) This requires the sender to have the recipient's public key in its keystore. The process for encrypting is  similar to the signature process detailed in the previous usecase.

Please use these parameters to configure the WSS4J class :

- Actions : Encrypt and Signature


ifdef::showscript[]

:numbered!:
= Teacher info

* Time estimated : 2d

* How to evaluate the solution of the student :

** Check if the Junit Tests are passing successfully
** Review the code submitted by the student, Java classes and frameworks technology used (Spring, Blueprint, CDI, ...)
** Review the solutions proposed by the student to resolve the different use cases
** For each use case, verify the SOAP Request and response populated. They should be comparable to what you can find within the +output/ws-*+ corresponding folder

endif::showscript[]
