:noaudio:
:sourcedir: ../code/security-ws/src/test/java
:toc2:

= REST Security with Basic Authentication and Role Lab

In this lab you resolve the following use cases:

<<usecase1>>

<<usecase2>>

.Goals
* Configure your local environment to develop and resolve use cases
* Become more experimented about Basic Authentication Jetty Server
* Restrict the access to certain paths based on the role of the user
* Design RESTfull Service project and secure it
* Expose the RESTfull services using a Camel route
* Configure the Jetty Endpoint to authenticate the HTTP User request using the HashLoginService
* Send the HTTP Request using Apache Commons HttpClient

.Prerequisites
* Experience with Java, Spring & Apache Maven
* Expertise with RESTfull & HTTP Basic Authentication
* Complete Red Hat OPEN course: Camel Development with Red Hat JBoss Fuse

:numbered:
== Install Lab assets

|===
| Software | Version & URL | Notes |

| Java SE | http://www.oracle.com/technetwork/java/javase/downloads/index.html[1.8 or higher] | Required |
| Apache Maven | http://maven.apache.org[3.0.5 or higher] | Required |
| JBoss Developer Studio | http://www.jboss.org/products/devstudio/overview/[9.0.GA] | Required |
| Integration Stack | https://devstudio.jboss.com/9.0/stable/updates/[9.0] | Required |
|===

=== Install the lab project

Download the latest release of the project published on the following GitHub repository: {course_git_repo} and install it locally. As this project contains the skeleton of the code
that you will use to resolve the use cases, we suggest that you next import it in a new Workspace of JBoss Developer Studio.


== Use case exercise

The different use cases should be developed as a collection of Java JUnit Test class within the corresponding Maven module part of the skeleton project.

[[usecase1]]
=== Secure the Jetty Component using a Security Handler

The goal of this use case is to design a Junit Test case where the class +org.jboss.fuse.security.camel.basic.BasicAuthRESTCamelDSLJettyHashLoginTest.java+ which extend the class +BaseJettyTest+ class will include a @Test Junit method responsible to issue a SOAP Message where the SOAP Header generated by the WSS4J Interceptor of the client
will include a SOAP WSSE header section with a username and a timestamp to authenticate the JAXWS Client request.

This use case should issue a message containing a SOAP header with a user and a wrong password and the test must validate that the exception message reported during the fail process contains this message "Security processing failed."

To enable WS-Security within CXF for a server or a client, you'll need to set up the WSS4J interceptors. This can be done via the API for standalone web services or via Spring XML configuration for servlet-hosted ones. In this usecase, we will use the former approach.

The CXF web service must be created using the +JaxWsServerFactoryBean+ class while the JAXWS client responsible to consume the echo service will be developed using the +JaxWsProxyFactoryBean+ class.
No HTTP Transport must be used to configure the client but only the CXF Local transport. Both classes should be developed using the CXF interceptor pattern in order to generate the SOAP WSSE Section header
and process this section at the server site. The framework Apache WSS4J must be used and configured with the the CXF In/Out Interceptors.

No wsdl file will be used for this project but instead Java classes annotated with the JAX-WS @WebService annotation. The Echo interface and EchoImpl java class implementing the interface have been provided within the project.

WS-Security supports many ways of specifying tokens including UsernameToken header. A username and password or password digest can be communicated to another endpoint. The password callback class allows you to retrieve the password for a given user so that WS-Security can determine if they're authorized.

For this use case, you will use as parameters to configure the WSS4J class the following properties :

- Actions : UsernameToken and Timestamp
- User : your user name as defined within the +org.jboss.fuse.security.service.PwdCallback+ class
- Password : a password which is incorrect
- Password Type : text

[NOTE]
====
* You can define the WSS4J parameters using the `setProperty` method of the class +AbstractWSS4JInterceptor+
* The JaxWsServerFactoryBean (server side) and JaxWsProxyFactoryBean (client side) must be configured to use the Crypto configuration files insecurity.properties and outsecurity.properties to sign/decrypt the messages using the parameters +signatureVerificationPropFile+ and +decryptionPropFile+. The properties files should be created within the resources directory +org/jboss/fuse/security/common+
* Both Crypto config files will use the same keystore file +integrationstore.jks+
====

[[usecase2]]
=== Generate SOAP Header with WSSE : username, timestamp & password

This usecase extends the previous but instead of sending a wrong password, you will send the correct password assigned to your username within the WSSE Section of the SOAP Header. Please use the `passwordCallbackClass` as WSS4J parameter
to let the Interceptor to get the password from the `PwdCallback` implementing the `CallbackHandler` interface. Within the handle method, loop within the list of the users till you find the user and assign the password
to the `WSPasswordCallback` object using the `setPassword` property.

Use the same Actions as defined for the Usecase 1 in order to generate a header containing the user credential and the timestamp.

[[usecase3]]
=== Generate a SOAP Message & sign its content

The goal of this use case is to sign the body of the message and its timestamp. The algorithms to be used to digest the signed content is +http://www.w3.org/2001/04/xmlenc#sha256+ while the algorithm to be used to sign the content is +http://www.w3.org/2000/09/xmldsig#rsa-sha1+.
You will need to set the Signature and TimeStamp actions (username token does not need to be set).

Signing a message validates to the receiver that the message was not altered in transit and could only have come from a certain sender. The sender encrypts a digest (hash) of the message with its private key, and the recipient decrypts the hash with the sender's public key.  It checks that the digest values calculated by both the sender and recipient are the same. The student  must ensure that the Client's public key has been imported into the server's keystore using keytool.

Please use these parameters to configure the WSS4J class :

- Actions : Timestamp and Signature
- Parts to be signed : signatureParts
- Parts : body and timestamp
- Sign Algorithm : signatureAlgorithm
- Digest Sign Algorithm : signatureDigestAlgorithm

[WARNING]
====
* Take care to configure accordingly the Server and/or client classes and the In/Out interceptors
* Use the appropriate user to sign the message based on the key associated to its certificate
====

[[usecase4]]
=== Generate a SOAP Message & sign/encrypt the content

For this last use case, you will encrypt and sign the content of the message.

Encryption involves the sender encrypting the message with the recipient's public key to ensure that only the recipient can read the message (only the recipient has its own private key, necessary for decrypting the message.) This requires the sender to have the recipient's public key in its keystore. The process for encrypting is  similar to the signature process detailed in the previous usecase.

Please use these parameters to configure the WSS4J class :

- Actions : Encrypt and Signature


ifdef::showscript[]

:numbered!:
= Teacher info

* Time estimated : 2d

* How to evaluate the solution of the student :

** Check if the Junit Tests are passing successfully
** Review the code submitted by the student, Java classes and frameworks technology used (Spring, Blueprint, CDI, ...)
** Review the solutions proposed by the student to resolve the different use cases
** For each use case, verify the SOAP Request and response populated. They should be comparable to what you can find within the +output/ws-*+ corresponding folder

endif::showscript[]
