:noaudio:

[#tokenizexml]
== Tokenize XML

* Goal: Split XML content
* Available using TokenizeXML & XTokenize languages
+
.Example
[source,xml]
----
<from uri="file:inbox"/>
  <split streaming="true">
    <tokenize token="order" xml="true"/>
    <to uri="activemq:queue:order"/>
  </split>
----
* XTokenize uses Stax Parser
* Best suited for complex XML Processing
+
.Example
[source,xml]
----
<from uri="file:target/xtokenizer"/>
   <split>
     <!-- split the file using XML tokenizer, where we grab the order tag,
          and inject the namespaces declarations from its ancestor nodes -->
     <xtokenize>//s:orders/s:order</xtokenize>
----

ifdef::showscript[]
[.notes]
****

== Tokenize XML

In order to process XML Streams and split them, the expression languages tokenizeXML and xtokenize are available. Even if they both support the same philosophy which is to split the XML content based on a
XML tag, they uses a different Api under the hood. The tokenizeXML expression language will use a regular expression to parse and extract the tag from the XML stream while xtoken relies on the Stax Api.

So, by example, if the XML to be parsed contains a list of <order> tags defined under the <orders> parent tag, then by using the token attribute "order", the content splitted will contain each <order>
and closing <order> tag with its content. You can also inherit a namespace defined in a parent tag by setting the attribute inheritNamespaceTagName within the XML tag or by passing a second parameter to the
fluent DSL method with the name of the tag containing the namespace to be included within the response.

To build more complex XML expression to split the content, we recommend to use the xtokenize language. This tokenizer recognizes XML namespaces and also handles simple and complex XML structures more naturally and efficiently.
Two arguments control the behavior of the tokenizer. The first argument specifies the element using a path notation. This path notation uses a subset of xpath with wildcard support. The second argument represents the extraction mode.
The available extraction modes are: i which is the default behavior and injects the contextual namespace bindings into the extracted token, w wrapps the extracted token in its ancestor context, u	unwraps the extracted token to its child content
and t extracts the text content of the specified element.

Note that this StAX based tokenizer's uses StAX Location API and requires a StAX Reader implementation (e.g., woodstox) that correctly returns the offset position pointing to the beginning of each event triggering segment (e.g., the offset position of '<' at each start and end element event).
If you use a StAX Reader which does not implement that API correctly it results in invalid xml snippets after the split

****
endif::showscript[]