:noaudio:
:toc2:

= Web Service Security Policy Lab

In this lab you resolve the following use cases:

<<usecase1>>

<<usecase2>>

<<usecase3>>

<<usecase4>>

.Goals
* Configure your local environment to develop and resolve use cases
* Become more experimented about WS-SecurityPolicy specification
* Design Web Service project and secure it
* Send and receive SOAP messages using the CXF Bus & SpringBusFactory classes with XML Config Files

.Prerequisites
* Experience with Java, Spring & Apache Maven
* Expertise with Web Service Technology & SOAP Messages
* PKI & encryption/decryption background
* Complete Red Hat OPEN course: Camel Development with Red Hat JBoss Fuse

:numbered:
== Install Lab assets

|===
| Software | Version & URL | Notes |

| Java SE | http://www.oracle.com/technetwork/java/javase/downloads/index.html[1.8 or higher] | Required |
| Apache Maven | http://maven.apache.org[3.0.5 or higher] | Required |
| JBoss Developer Studio | http://www.jboss.org/products/devstudio/overview/[9.0.GA] | Required |
| Integration Stack | https://devstudio.jboss.com/9.0/stable/updates/[9.0] | Required |
| SoapUI | http://sourceforge.net/projects/soapui/files/[latest version] | Optional |
|===

=== Install the lab project

Download the latest release of the project published on the following GitHub repository: {course_git_repo} and install it locally. As this project contains the skeleton of the code
that you will use to resolve the use cases, we suggest that you next import it in a new Workspace of JBoss Developer Studio.

=== Keys and certificates

Follow these instructions in order to create the Private/Public keys of the users to be used and their corresponding certificates

[source]
----
keytool -genkey -alias integration  -keyalg RSA  -keypass secUr1t8 -storepass secUr1t8 -keystore security/src/test/resources/integrationstore.jks
----

Add `localhost` as name for the first and last name field. You can define the value for the other fields as you want.
Here is an example `CN=localhost, OU=integration, O=enablement, L=fuse, ST=Unknown, C=US`

== Use case exercise

The different use cases should be developed as a collection of Java JUnit Test class within the corresponding Maven module part of the skeleton project.

[[usecase1]]
=== Create a WSDL File with a Web Service Policy to authenticate the user name token

The goal of this use case is to design a Junit Test case to start a CXF Bus Server and to use the CXF JAWS client endpoint in order to issue a SOAP Message using +WS-SecurityPolicy+ as security specification.

The binding and/or operation in the wsdl references a WS-Policy fragment that describes the basic security requirements for interacting with that service. The WS-SecurityPolicy specification allows for specifying things like asymmetric/symmetric keys, using transports (https) for encryption, which parts/headers to encrypt or sign, whether to sign then encrypt or encrypt then sign, whether to include timestamps, whether to use derived keys. The actions necessary to securely interact with the service are described in the WSDL. However, the user still needs to describe things such as locations of key stores, user names and passwords. 

So, the challenge of this use case will be to configure appropriately the Policy, part of the WSDL file, to generate the SOAP Message & WSSE section with the information required to authenticate, sign or encrypt the content of the message.

The Java class +org.jboss.fuse.security.WSSecurityPolicyTest+ which extend the +AbstractBusClientServerTestBase+ class will include @Test Junit methods responsible to issue the SOAP Messages where the SOAP Header is not longer generated
by the WSS4J interceptors of CXF but using some Web Service Policy that you will define within the WSDL contract of the Web Service.

Contrary to the use case implemented with the +WSSecurityTest+ test class, you will here use a Server class to launch the CXF Bus and to expose the Web Service endpoint. This CXF Bus will be created using the SpringBusFactory class and will use as parameter the Spring XML config file containing
the Beans defined to configure the CXF Server.

The +Server+ class is created with the help of the +launchServer+ utility class with the method +startServers+ which is annotated with the annotation @BeforeClass.
Define using the String Array object the path to access the resource of the Spring Beans XML file to launch the Server.

[source]
----
@BeforeClass
public static void startServers() throws Exception {
    assertTrue("Server failed to launch",
            // run the server in the same process
            // set this to false to fork
            launchServer(Server.class, null, new String[] { "/path/to/access/server.xml" }, true));
}
----

Similarly, the client issuing the SOAP request and waiting for the SOAP response from the Web Service will be created using a SpringBusFactory class of the Apache CXF Framework. This class and the CXF Bus to be created
contains a method +setDefault(Bus bus)+ that you will use to configure the Bus with its Spring Beans XML config file. Like the Server, you must define the XML file with the appropriate CXF beans.

To setup the project, you must create the Spring Beans XML file for the server and the client within the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+ as such

.Server
* Add the <cxf:bus> containing the <cxf:features> and the logging Feature
* Setup the <jaxws:endpoint/> bean to use the the WSDL location file +src/test/resources/org/jboss/fuse/security/wssecuritypolicy/hello_world.wsdl+
* Use the +org.jboss.fuse.security.service.GreeterImpl+ service
* Expose the service at this address +https://localhost:9001/ws/Hello+
* Configure the <httpj:engine-factory/> and its <httpj:engine port="9001"> bean to setup the TLS layer with the +src/test/resources/integrationstore.jks+ keystore file
* Authenticate the client by configuring the property <sec:clientAuthentication/>

.Client
* Add the <cxf:bus> containing the <cxf:features> and the logging Feature
* Add the <jaxws:client/> bean to configure the CXF HTTP Client
* Pass as parameters the required +ws-security.*+ attributes to specify the user to be used for Basic HTTP authentication and the +callback-handler+ attribute pointing to the Password Call Back class +org.jboss.fuse.security.service.PwdCallback+
* Use the <http:conduit/> bean to setup the TLS layer of the HTTP Client

.Common method
* Create within the Junit Test class the method +runandValidate+ responsible to configure the SpringFactoryBus of the Client for each Junit Test,
* Instantiate the +SpringBusFactory+ and set the Bus with the location of the XML file as such

[source]
----
SpringBusFactory bf = new SpringBusFactory();

Bus bus = bf.createBus(busFile.toString());
SpringBusFactory.setDefaultBus(bus);
SpringBusFactory.setThreadDefaultBus(bus);
----

* Setup the +javax.xml.ws.Service+ class to configure the Web Service Client as such

[source]
----
URL wsdl = WSSecurityPolicyEncryptTest.class.getResource("/" + wsdlFile);
Service service = Service.create(wsdl, SERVICE_QNAME);
QName portQName = new QName(NAMESPACE, portName);
Greeter greeter =
        service.getPort(portQName, Greeter.class);

String response = greeter.greetMe("Charles");
assertEquals(response,assertString);
----

* Pass the following parameters +URL busFile, String portName, String assertString, String wsdlFile+ to the method +runandValidate+ as they will be used to respectively:
** Create the Spring Bus +SpringBusFactory.createBus(URL Bus)+
** Create the +javax.xml.namespace.QName+ with the namespace and the Qport of the Web Service to call +QName portQName = new QName(NAMESPACE, portName);+
** The AssertString to be checked against the response returned by the SOAP Response message
** The location of the SDL file that is needed to create the Service +Service.create(wsdl, SERVICE_QNAME)+

.Unit Test

* Create a Junit Test with the +testUsernameToken()+ method where you will issue a SOAP request with the following parameters

[source]
----
URL busFile = WSSecurityPolicyTest.class.getResource("client.xml");
runandValidate(busFile, "GreeterPort", "Hello Charles", "org/jboss/fuse/security/common/hello_world.wsdl");
----

[NOTE]
====
* The client.xml file defined within the snippet code corresponds to the Spring XML Beans config of the CXF Client
* The wsdl +Hello World+ will contain the WebService Policy to authenticate the user name and issue a TimeStamp
====

.WSDL and Policy

WS SecurityPolicy uses WS Policy assertions within the WSDL file to define the secure exchange to messages. Some of the policy assertions that are interesting to this use case are:
- `TransportBinding` which sets the TLS security attributes
- `SupportingToken` which deal with user sign-on (username,password)

* Create within the HelloWorld WSDL file a policy with this id +<wsp:Policy wsu:Id="GreetMeAuthenticationPolicy"+
* Configure the Port section to use this Security Policy +<wsdl:port binding="tns:GreeterBinding" name="GreeterPort">+
* Design this Policy to include the User Name token +<sp:UsernameToken/> + with a hashed password and a TimeStamp +<sp:IncludeTimestamp/>+

Check that the AssertString +Hello Charles+ corresponds to the String returned by the method called +String response = greeter.greetMe("Charles");+

[[usecase2]]
=== Issue a SOAP request with a wrong password

This usecase extends the previous but we will issue a SOAP message where the password used for the user is wrong. Some modifications are required within your project to design this use case.
Here are the steps to follow :

.Spring XML Client File
* Create a new +client-wrongpassword.xml+ file within the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+ using the content of the file that you have created within the previous use case
* Configure the +ws-security.password+ key passed as parameter to the +<jaxws:properties>+ of the JAXWS Bean endpoint with a dummy password

.Junit Method
* Add a new method +testUsernameTokenWrongPassword+ within the Java +WSSecurityPolicyTest+ Test class
* Change the URL of the Bus file to point to your +client-password.xml+ config file
* Include a try/catch block section to get the SOAP Fault Message returned and verify that it fails
* Add a +assertEquals+ method to control that you get this error message from the Java Stack Trace +"A security error was encountered when verifying the message"+

[source,xml]
----
try {
    runandValidate(busFile,"GreeterPort","Hello Charles","org/jboss/fuse/security/common/hello_world.wsdl");
    fail("Exception expected");
} catch(Exception ex) {
    assertEquals(TODO);
}
----

[[usecase3]]
=== Generate a SOAP Message & sign its content

The goal of this use case is to sign the body and the TimeStamp of the SOAP message using a new Web Security Policy +GreetMeSignedPolicy+ that you will create as a separate file and not within the wsdl file.
Like the first use case, the username token must be added to the SOAP Header secured section with a hashed password.

Here are some indications that we provide you to develop the project

.Spring XML Server file
* Create a new +server-signed.xml+ file within the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+
* Add the key +ws-security.signature.properties+ to the +<jaxws:properties/>+ bean to point to the properties file containing the keystore used to digest/sign the SOAP content
* Configure the +<jaxws:endpoint/>+ endpoint with a +<jaxws:features>+ bean to pass the location of the +signed-body-policy.xml+ file containing the Policy designed

.Spring XML Client File
* Create a new +client-signed.xml+ file within the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+
* Reuse the code created for the first use case and change the WSDL Port of the HTTPConduit & JAXS Bean to use the +GreeterSignedPort+
* Add the key +ws-security.signature.properties+ to the +<jaxws:properties/>+ bean to point to the properties file containing the keystore used to digest/sign the SOAP content
* Configure the +<jaxws:endpoint/>+ endpoint with a +<jaxws:features>+ bean to pass the location of the +signed-body-policy.xml+ file containing the Policy designed

.Sign Body and TimeStamp Policy
* Create the +signed-body-policy.xml+ file under the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+
* Develop the policy to sign the Body and the TimeStamp Header
* Generate the Username Token within the SOAP Header with a hashed password
* Include a +TimeStamp+ within the SOAP WSSE Header
* The algorithm to sign the parts of the messahe is +Basic128+
* Use +AsymmetricBinding+ and the +WssX509V3Token10+ to sign/decrypt the SOAP signed parts for the +InitiatorSignatureToken+ and the +RecipientSignatureToken+

.New Test class
* Add a new Java Test class with the name +WSSecurityPolicySignTest+ and include an annotated method +testSignature+
* Launch the server using the Spring XML file +org/jboss/fuse/security/wssecuritypolicy/server-signed.xml+
* Use as Bus URL, the +client-signed.xml+ file to configure the CXF Spring Bus
* Configure the +runAndValidate+ method to use the +hello_world.wsdl+ file packaged under the folder +src/test/resources/org/jboss/fuse/security/wssecuritypolicy+

[[usecase4]]
=== Generate a SOAP Message & sign/encrypt the content

For this last use case, you will encrypt and sign the content of the message (header and Body). Like the previous use case, you will create a new Java Test class, new Spring XML config files for the client/server
and the WS-Security policy file containing the policies according to the following convention

Java class : +org/jboss/fuse/security/wssecuritypolicy/WSSecurityPolicyEncryptTest.java+
Spring Server Beans file : +src/test/resources/org/jboss/fuse/security/wssecuritypolicy/server-sign-encrypt.xml+
Spring Client Beans file : +src/test/resources/org/jboss/fuse/security/wssecuritypolicy/client-signencrypt.xml.xml+
WS-Security Policy file : +src/test/resources/org/jboss/fuse/security/wssecuritypolicy/signencrypt-policy.xml+

Here are some inputs to configure the WS-Security Policy file

.Sign/Encrypt the Body and Headers
* Develop the policy to sign/encrypt the Body and the Headers
* Include a +TimeStamp+ within the SOAP WSSE Header
* The algorithm to sign the parts of the messahe is +Basic128+
* Use +SymmetricBinding+ and a +ProtectionToken+ with the +X509+ token

ifdef::showscript[]

:numbered!:
= Teacher info

* Time estimated : 2d

* How to evaluate the solution of the student :

** Check if the Junit Tests are passing successfully
** Review the code submitted by the student, Java classes and frameworks technology used (Spring, Blueprint, CDI, ...)
** Review the solutions proposed by the student to resolve the different use cases
** For each use case, verify the SOAP Request and response populated. They should be comparable to what you can find within the +output/ws-*+ corresponding folder

endif::showscript[]
