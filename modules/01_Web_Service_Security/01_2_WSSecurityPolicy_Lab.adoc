:scrollbar:
:data-uri:
:linkattrs:
:toc2:

== Web Service Security Policy Lab

.Goals
* Configure your local environment to develop and explore use cases
* Become more familiar with WS-Security specification
* Design a web service project and secure it
* Send and receive SOAP messages using the CXF bus and `SpringBusFactory` classes with XML configuration files

.Prerequisites
* Experience with Java, Spring, and Maven
* Familiarity with web service technology and SOAP messaging
* Understanding of PKI and message encryption and signatures
* Experience with Camel development using JBoss Fuse

.Use Cases
In this lab, you explore four use cases:

* <<usecase1>>

* <<usecase2>>

* <<usecase3>>

* <<usecase4>>

Each use case is developed as a collection of Java JUnit test classes in the corresponding Maven module part of the skeleton project.

:numbered:

== Install Lab Assets

[cols="2,1,1",options="header"]
|====
| Software | Version | Notes
| link:http://www.oracle.com/technetwork/java/javase/downloads/index.html[Java SE^] | 1.8 or higher | Required
| link:http://maven.apache.org[Apache Maven^] | 3.0.5 or higher | Required
| link:http://www.jboss.org/products/devstudio/overview/[Red Hat JBoss Developer Studio^] | 9.0.GA | Required
| link:https://devstudio.jboss.com/9.0/stable/updates/[JBoss Developer Studio Integration Stack^] | 9.0 | Required
| link:http://sourceforge.net/projects/soapui/files/[SoapUI^] | Latest version | Optional
|====

=== Install Lab Project

Download and install locally the latest release of the project published on the {course_git_repo} GitHub repository. Because this project contains the skeleton code that you use to explore the use cases, import the project into a new JBoss Developer Studio workspace.

=== Create Keys and Certificates

For this lab, the keys are generated for you. Outside the lab environment, use the `keytool` command to create the private and public keys and corresponding certificates for your users:

[source,text]
----
keytool -genkey -alias integration  -keyalg RSA  -keypass secUr1t8 -storepass secUr1t8 -keystore security-ws/src/test/resources/integrationstore.jks
----

* When prompted for the first and last names, enter `localhost`.
* Specify any values for the other prompts.
* Answer `yes` to confirm the value of the Common Name (CN).
* Expect the resulting Common Name to look similar to this: `CN=localhost, OU=integration, O=enablement, L=fuse, ST=Unknown, C=US`.


[[usecase1]]
== Issue SOAP Request with Valid User Authentication

In this use case, you design a JUnit test case to start a CXF bus server and use the CXF JAWS client endpoint to issue a SOAP message using `WS-SecurityPolicy` as the security specification.

You create the WSDL file whose binding and operation references a WS-Policy fragment that describes the basic security requirements for interacting with the service. The WS-SecurityPolicy specification allows specifying:

* Required asymmetric/symmetric keys
* Transports (for example, HTTPS) to use for encryption
* Parts or headers to encrypt or sign
* Whether to sign then encrypt or encrypt then sign
* Whether to include timestamps
* Whether to use derived keys

While the actions necessary to securely interact with the service are described in the WSDL, the user must specify the locations of keystores, usernames, and passwords.

The challenges of this use case are to:

* Appropriately configure the `Policy` portion of the WSDL file.
* Generate the SOAP message and WSSE section with information required for authentication, signing, and encrypting the message content.

The `org.jboss.fuse.security.WSSecurityPolicyTest` Java class, which extends the `AbstractBusClientServerTestBase` class, includes `@Test` JUnit methods to issue the SOAP messages. You must implement these `@Test` JUnit methods.

The SOAP header is not generated by the WSS4J interceptors of CXF, but by using a web service policy that you define in the WSDL contract of the web service.

Contrary to the use case implemented with the `WSSecurityTest` test class, you use the `Server` class to launch the CXF bus and expose the web service endpoint.This CXF bus is created using the `createBus` method of the `SpringBusFactory` class', which takes as its parameter, the Spring XML configuration file containing the beans defined to configure the CXF server.

The `Server` class is created with the help of the `launchServer` utility method in the `startServers` method, which is annotated with the `@BeforeClass` annotation.

=== Set Up Project

. Define the path to the Spring beans XML file resource to launch the server using a String Array object:
+
[source,json]
----
@BeforeClass
public static void startServers() throws Exception {
    assertTrue("Server failed to launch",
            // run the server in the same process
            // set this to false to fork
            launchServer(Server.class, null, new String[] { "/path/to/access/server.xml" }, true));
}
----

* The client issuing the SOAP request and waiting for the SOAP response from the web service is created using the Apache CXF framework's `SpringBusFactory` class.

* The `SpringBusFactory` class and the CXF bus to be created contain a `setDefault(Bus bus)` method that you use to configure the bus with its Spring Beans XML configuration file.

. Create the Spring beans XML file for the server and the client in the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder.


=== Set Up Server

In this section, you use the server Spring beans XML file you created in the previous step.

. Add a `<cxf:bus>` element containing a `<cxf:features>` element, and in that element, configure the logging feature.
. Set up the `<jaxws:endpoint/>` bean to use the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy/hello_world.wsdl` WSDL file.
. Use the `org.jboss.fuse.security.service.GreeterImpl` service.
. Expose the `https://localhost:9001/ws/Hello` service.
. Configure `<httpj:engine-factory/>` and its `<httpj:engine port="9001">` bean to set up the TLS layer with the `src/test/resources/integrationstore.jks` keystore file.
. Authenticate the client by configuring the `<sec:clientAuthentication/>` property.

=== Set Up Client

In this section, you use the client Spring beans XML file you created earlier.

. Add the `<cxf:bus>` element containing a `<cxf:features>` element, and in that element, configure the logging feature.
. Add the `<jaxws:client/>` bean to configure the CXF HTTP client.
. Pass as parameters the required `ws-security.*` attributes to specify the user to be used for Basic HTTP authentication and the `callback-handler` attribute pointing to the Password callback class `org.jboss.fuse.security.service.PwdCallback`.
. Use the `<http:conduit/>` bean to set up the TLS layer of the HTTP client.

=== Create Common Method

. In the JUnit test class, create the `runandValidate` method to configure the client's `SpringFactoryBus` for each JUnit test.
. Instantiate the `SpringBusFactory` object, create a bus with the location of the XML file as a parameter, and set this bus as the default.
+
[source,java]
----
SpringBusFactory bf = new SpringBusFactory();

Bus bus = bf.createBus(busFile.toString());
SpringBusFactory.setDefaultBus(bus);
SpringBusFactory.setThreadDefaultBus(bus);
----

. Set up the `javax.xml.ws.Service` class to configure the web service client:
+
[source,java]
----
URL wsdl = WSSecurityPolicyEncryptTest.class.getResource("/" ` wsdlFile);
Service service = Service.create(wsdl, SERVICE_QNAME);
QName portQName = new QName(NAMESPACE, portName);
Greeter greeter =
        service.getPort(portQName, Greeter.class);

String response = greeter.greetMe("Charles");
assertEquals(response,assertString);
----

. Pass the `URL busFile`, `String portName`, `String assertString`, `String wsdlFile` parameters to the `runandValidate` method.

* The `URL busFile` parameter is used to create the `SpringBusFactory.createBus(URL bus)` Spring bus.
* The `String portName` parameter is used to create the `javax.xml.namespace.QName` object. The other parameter to the `QName` constructor is the namespace, specified by the `NAMESPACE` constant.
* The `String assertString` parameter is used to check the response from the SOAP response message.
* The `String wsdlFile` parameter specifies the location of the WSDL file that is used to create the service.

=== Create JUnit Test

. Create a JUnit test with the `testUsernameToken()` method and issue the SOAP request in this method:
+
[source, java]
----
URL busFile = WSSecurityPolicyTest.class.getResource("client.xml");
runandValidate(busFile, "GreeterPort", "Hello Charles", "org/jboss/fuse/security/common/hello_world.wsdl");
----

* The `client.xml` file defined in the snippet code corresponds to the Spring XML beans configuration of the CXF client.
* The WSDL `Hello World` contains the WebService Policy to authenticate the username and issue a timestamp.


=== Set WSDL and Policy

WS-SecurityPolicy uses WS Policy assertions in the WSDL file to define a secure message exchange. For example, the following assertions are relevant to this use case:

* `TransportBinding` sets the TLS security attributes
* `SupportingToken` specifies the username and password for user authentication

. In the `HelloWorld` WSDL file, create the `<wsp:Policy wsu:Id="GreetMeAuthenticationPolicy">` policy.

. Configure the port section to use the `<wsdl:port binding="tns:GreeterBinding" name="GreeterPort">` Security Policy.

. Design this policy to include a `<sp:UsernameToken/>` element with a hashed password and the `<sp:IncludeTimestamp/>` element.

. Verify that the `AssertString` "Hello Charles" corresponds to the string returned by the `String response = greeter.greetMe("Charles");` method.


[[usecase2]]
== Issue SOAP Request with Invalid Password

In this use case, you expand on the previous example. You issue a SOAP message where the user's password is incorrect. Some modifications are required in your project to design this use case.

=== Create Spring XML Client File

. Create a new `client-wrongpassword.xml` file in the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder using the file's contents from the previous use case.

. Configure the `ws-security.password` key passed as parameter to the `<jaxws:properties>` of the JAXWS bean endpoint with a dummy password.

=== Add JUnit Method

. Add a new `testUsernameTokenWrongPassword` method in the `WSSecurityPolicyTest` Java test class.
. Change the URL of the bus file to point to your `client-password.xml` configuration file.
. Include a try/catch block section to get the SOAP fault message returned and verify that it fails.
. Add a `assertEquals` method to check that you get a `"A security error was encountered when verifying the message"` error message from a Java stack trace.

* Expect your source to look similar to this:
+
[source,xml]
----
try {
    runandValidate(busFile,"GreeterPort","Hello Charles","org/jboss/fuse/security/common/hello_world.wsdl");
    fail("Exception expected");
} catch(Exception ex) {
    assertEquals(TODO);
}
----


[[usecase3]]
== Generate SOAP Message and Sign Content

In this use case, you sign the `Body` and `Timestamp` of the SOAP message using the `GreetMeSignedPolicy` web security policy. You create this as a separate file and not in the WSDL file. As in the first use case, the `UsernameToken` must be added to the SOAP header and must include a hashed password.

=== Create Spring XML Server File

. Create a new `server-signed.xml` file in the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder.

.  Add the `ws-security.signature.properties` key to the `<jaxws:properties/>` bean to point to the properties file containing the keystore used to digest and sign the SOAP content.

.  Configure the `<jaxws:endpoint/>` endpoint with a `<jaxws:features>` bean to pass the location of the `signed-body-policy.xml` file containing the designed policy.

=== Create Spring XML Client File

. Create a new `client-signed.xml` file in the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder.

. Reuse the code created for the first use case and change the WSDL port of the HTTPConduit and JAXS bean to use `GreeterSignedPort`.

. Add the `ws-security.signature.properties` key to the `<jaxws:properties/>` bean to point to the properties file containing the keystore used to digest and sign the SOAP content.

. Configure the `<jaxws:endpoint/>` endpoint with a `<jaxws:features>` bean to pass the location of the `signed-body-policy.xml` file containing the policy you designed.

=== Sign Body and Timestamp Policy

. Create the `signed-body-policy.xml` file under the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder.
. Develop a policy to sign the `Body` and the `Timestamp` header.
. Generate the `UsernameToken` in the SOAP header with a hashed password.
. Include a `Timestamp` in the SOAP WSSE `Security` element within the SOAP `Header`.
* The algorithm to sign the parts of the message is `Basic128`.
. Use `AsymmetricBinding` and the `WssX509V3Token10` to sign/decrypt the SOAP signed parts for the `InitiatorSignatureToken` and `RecipientSignatureToken`.

=== Add Test Class

. Add a new Java test class with the `WSSecurityPolicySignTest` name and include an annotated `testSignature` method.
. Launch the server using the `org/jboss/fuse/security/wssecuritypolicy/server-signed.xml` Spring XML file.
. Use as the bus URL the `client-signed.xml` file to configure the CXF Spring bus.
. Configure the `runAndValidate` method to use the `hello_world.wsdl` file packaged under the `src/test/resources/org/jboss/fuse/security/wssecuritypolicy` folder.


[[usecase4]]
== Generate SOAP Message and Sign/Encrypt Content

In this use case, you encrypt and sign the content of the message (header and body). You follow an approach similar to the previous use case.

. Create a new Java test class:  `org/jboss/fuse/security/wssecuritypolicy/WSSecurityPolicyEncryptTest.java`
. Create a new Spring XML configuration file for the client:  `src/test/resources/org/jboss/fuse/security/wssecuritypolicy/client-signencrypt.xml.xml`
. Create a new Spring XML configuration files for the server:  `src/test/resources/org/jboss/fuse/security/wssecuritypolicy/server-sign-encrypt.xml`
. Create a WS-Security policy file containing the policies:  `src/test/resources/org/jboss/fuse/security/wssecuritypolicy/signencrypt-policy.xml`

=== Sign and Encrypt Body and Headers

. Configure the WS-Security policy file.
. Develop a policy to sign and encrypt the `Body` and the headers.
. Include a `Timestamp` in the SOAP WSSE `Security` element of the SOAP `Header`.
* The algorithm to sign the parts of the message is `Basic128`.
. Use `SymmetricBinding` and a `ProtectionToken` with the `X509` token.

ifdef::showscript[]

:numbered!:

== Teacher Information

* Time estimated: 2d

* How to evaluate the student's solution:

** Verify that the JUnit tests are passing successfully.
** Review the code submitted by the student, Java classes and frameworks technology used (Spring, Blueprint, CDI, etc.)
** Review the solutions proposed by the student to resolve the different use cases.
** For each use case, verify that the SOAP request and response populated. They should be comparable to what you can find in the `output/ws-*` corresponding folder.

endif::showscript[]
